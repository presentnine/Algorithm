# 알고리즘 7(그래프)

[그래프의 기본 개념]()

## 인접행렬 VS 인접리스트

### 인접행렬(adjacency matrix)

 정점의 개수가 n개인 그래프의 연결 관계를 각 정점의 인덱스를 부여하여 **n x n 크기의 2차원 배열로 표현**하는 방법.

![adjacent_matrix](C:\Users\admin\Desktop\MD 폴더\알고리즘\알고리즘 7\adjacent_matrix.png)

 이 때 배열 M에 대하여 요소 **M\[i]\[j]의 의미**는 정점 i에서 정점 j로 가는 **간선이 존재함**을 나타낸다. 추가적으로 해당 **간선의 가중치**를 담을 수도 있다.



#### 특징

* 자체 간선이 존재하지 않으면 대각선 성분이 모두 0
* **무방향 그래프**의 경우 대각선에 대하여 **대칭**을 띈다.

#### 장점

* 두 정점 간의 **간선 존재 유무를 확인**하는데 단순 인덱스 접근을 하면 되기에 **O(1)의 시간 복잡도**를 가진다.
* 구현이 단순하고, 직관적 형태를 띄고 있다.
* **간선을 추가**하는데 **O(1)의 복잡도**를 가진다.

#### 단점

* 정점의 개수가 많아질수록, 간선의 개수가 적어질수록 **메모리의 효율이 매우 떨어진다**.
* 해당 **정점과 연결된 정점들을 찾기 위해** 한 행 또는 한 열을 모두 탐색해야 하므로 n개의 정점으로 이루어진 그래프에 대해 **O(n)의 시간 복잡도**를 가진다.



### 인접 리스트(adjacency list)

 정점의 개수가 n개인 그래프의 연결 관계를 각 정점의 인덱스를 부여하여 **해당 인덱스(정점)를 헤더**로 정점과 연결되어 있는 **다른 정점들에 대한 정보를 연결리스트로 표현**하는 방법.

![adjacency_list](C:\Users\admin\Desktop\MD 폴더\알고리즘\알고리즘 7\adjacency_list.png)

#### 특징

* 한 연결리스트 속 **리스트의 순서는 크게 상관이 없다**.
* 특정 정점을 헤더로 하기 때문에 정점에 대한 접근은 빠르게 할 수 있다.

#### 장점

* 간선의 개수만큼만 리스트로 저장하기에 **메모리를 효율적으로 사용 가능**하다.
* 진출 차수를 구하는 데 효율적이다.

#### 단점

* 특정 정점의 **진입 차수**를 구하기 위해 **각 헤드를 모두 조사**해야 한다.
* 특정 정점의 간선을 넣기 위해 **연결리스트를 탐색**하며 마지막까지 가야한다.



## 순회(탐색)

 하나의 정점으로부터 시작하여 차례대로 **모든 정점들을 한 번씩 방문**하는 것으로, 많은 문제들이 그래프의 노드를 순회하는 것으로 해결할 수 있다. (ex 도시 간의 연결 여부)



### 깊이 우선 탐색(DFS)

 **특정 방향**으로 갈 수 있을 때까지 탐색을 진행하다 더 이상 불가능하면 가장 가까운 분기점으로 돌아가 탐색을 재개하는 방법으로, 되돌아가기 위해 **스택을 사용**한다.

* 이 경우 **재귀 호출**을 통한 **시스템 스택을 사용**할 수 있다.



#### DFS의 의사 코드(인접행렬 기준)

```c++
DFS(v)
    visited[v] <- true
    for w <- 0 to n-1 do
        if(M[v][w]!=0 && !visited[w])
            DFS(w)
```

* 해당 정점을 방문 배열에 표시
* 모든 정점에 대하여 정점 v와 연결되어 있고 아직 방문하지 않은 정점들에 대해 **함수 반복 호출**



### 너비 우선 탐색(BFS)

 시작 정점으로부터 가까운 정점을 먼저 탐색하고 멀리 떨어져 있는 정점을 나중에 방문하는 탐색 방법으로, **큐를 사용**한다.



#### BFS의 의사 코드(인접행렬 기준)

```c++
BFS(v)
    Queue q
    visited[v] <- true
    enqueue(q, v)
    
    while(!is_empty(q))
        v = dequeue(q)
        for w <- 0 to n-1 do
            if(M[v][w]!=0 && !visited[w])
                visited[w] <- true
                enqueue(q, w)
```

* 해당 정점을 방문 배열에 표시
* 큐에 정점을 push
* 큐에서 정점 하나를 pop한 다음, 해당 정점과 연결되어 있고 아직 방문하지 않은 정점들에 대해 방문 표시를 하고 **큐에 다시 집어 넣음**
* 큐가 빌 때까지 **반복**

